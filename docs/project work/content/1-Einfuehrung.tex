% !TeX encoding=utf8
% !TeX spellcheck = de-DE

\chapter{Einführung, Allgemeines}

Im Rahmen des Softwareprojekts 2 gilt es, aus dem Bereich der Algorithmen und Datenstrukturen oder der Numerik eine lauffähige Applikation zu programmieren und angemessen zu dokumentieren. Die Auswahl der vorgeschlagenen Themen war breit gestreut (auch ein eigenes Thema konnte nach Absprache mit dem Fachbetreuer umgesetzt werden).

Ziele dieses Softwareprojekts sind unter anderem, unser bisheriges Wissen in der Praxis anzuwenden und unsere Programmierkenntnisse zu vertiefen. Ebenso soll die eigene Erfahrung im   Projektmanagement vertieft werden (Planung, Schätzung, Arbeitsteilung). \\\\


% % % Fragen
% Kapitelbeginn (chapter) nicht nur auf ungeraden Seiten



[Einleitung ins Projekt, Allgemeines]

\vspace*{1cm}


% \hspace*{3cm} Test Bibliographie (Zitatverweis): \cite[S. 115]{ds-ant}


\section{Vorwort (Überblick, Überlegungen, Schwierigkeiten)}

\begin{itemize}[noitemsep]
\item Überblick über die Arbeit geben (evtl. auch Programmstruktur?)
\item Wichtige Entscheidungen kurz erwähnen
\item Schwierigkeiten aufzeigen (z.B. bezüglich der Technologie)
\end{itemize}


Zuerst wurde geprüft, ob das Projekt mit JavaScript und einer Game Framework wie quintus oder ??? als Website umgesetzt werden könnte (Canvas für 2D). Allerdings hat ein Test gezeigt, dass bereits ab einer Anzahl von 10'000 einzelnen Elementen (sprites) das Rendering in HTML5 bezüglich der Geschwindigkeit überhaupt nicht akzeptabel war. Daher wurde entschieden, den Algorithmus mit Python und dem Framework pygame umzusetzen, das auf der C-Library STL basiert und dessen Leistung sehr gut ist. Das fertige Programm wird so eine ausführbare Datei sein.

\vspace*{1cm}

Weiter unten: Systemspezifische Beschränkungen erwähnen (Leistung), evtl. auf Optimierungsparameter eingehen

\vspace*{1cm} 

\begin{itemize}[noitemsep]
\item PGU: Library für Slider und Textfelder, etc.
\item Optimierung: Anzahl Partikel; Speicherbedarf
\item Klassendiagramme und Mockups (von Hand) zeichnen
\item Zwei Modi (mehrere Render-Möglichkeiten des Algorithmus)
\item Anfangs: 2D; trotzdem 3D-Koordinaten einbauen (dafür: WebGL als weiterer Renderer)
\item Einbau von Hindernissen
\end{itemize}


Links, etc. dokumentieren \\


\vspace*{1cm}




\section{Anforderungen}

Die erstellte Applikation sollte auf einem Computer lauffähig sein (ausführbare Datei), allenfalls in Form einer Webseite in einem Browser laufen. Der Code ist angemessen zu dokumentieren und das Projekt in Form einer Arbeit für ein interessiertes Publikum zu dokumentieren. Am Ende wird das Projekt der ganzen Klasse präsentiert. \\


Vgl. meine Notizen (offiziell und projektspezifisch) \\




\section{Theorie/Geschichtlicher Hintergrund} 

Evtl. kurz die Entwicklung der Algorithmen zur Ameisenkolonieoptimierung aufzeigen (vgl. die Literatur, Wikipedia-Artikel, u.ä.).


Die Ameisenkolonie-Optimierung (Ant Colony Optimization, ACO) richtet sich nach dem Verhalten von Ameisen bei der Wegfindung vom Nest zu Futterquellen, um damit verschiedene Probleme der kombinatorischen Optimierung zu lösen (vgl. \cite[S. 1]{sch-koa}). Dabei senden die Ameisen auf Futtersuche den Duftstoff Pheromon aus. Auf kürzeren Wegen ist die Pheromonkonzentration im Laufe der Zeit höher. Andere Ameisen richten sich bei ihrer Wegfindung nach der Höhe des Pheromons, so dass sie eher einen Weg mit hoher Pheromonkonzentration und damit einen kürzeren Pfad einschlagen. Es bildet sich eine sogenannte Ameisenstrasse aus.
Dieses Ameisenverhalten wurde auf Algorithmen übertragen. Der erste dieser Art wurde 1991 von Marco Dorigo publiziert, und zwar zur Lösung des Problems des Handlungsreisenden (Traveling Salesman Problem, TSP). 1999 steuerte Thomas Stützle entscheidende Ergänzungen bei (vgl. \cite{ds-ant; wiki-antalg}). \\\\

Beschreibung der Besonderheiten (Heuristik: nicht zwingend korrekte Lösung) \\

Mögliche Anwendungen beschreiben (vgl. auch Wikipedia) \\

Vgl. auch Schiller


\vspace*{1cm}
