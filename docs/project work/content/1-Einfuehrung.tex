% !TeX encoding=utf8
% !TeX spellcheck = de-DE


% % % Fragen
% Kapitelbeginn (chapter) nicht nur auf ungeraden Seiten



\chapter{Einführung}

Im Rahmen des Softwareprojekts 2 gilt es, aus dem Bereich der Algorithmen und Datenstrukturen oder der Numerik eine lauffähige Applikation zu programmieren und angemessen zu dokumentieren. Die Auswahl der vorgeschlagenen Themen war breit gestreut (auch ein eigenes Thema konnte nach Absprache mit dem Fachbetreuer umgesetzt werden).

Ziele dieses Softwareprojekts sind unter anderem, unser bisheriges Wissen in der Praxis anzuwenden und unsere Programmierkenntnisse zu vertiefen. Ebenso soll die eigene Erfahrung im   Projektmanagement vertieft werden (Planung, Schätzung, Arbeitsteilung).

In diesem ersten Kapitel erfolgt eine Einführung in allgemeine Aspekte des Themas. Einen Überblick über das Projekt liefert das zweite Kapitel, während das Programm detailliert im dritten Kapitel vorgestellt wird. Im vierten Kapitel werden die Erkenntnisse aus dem Projekt dargestellt, bevor eine Zusammenfassung folgt. \\

\noindent
Insbesondere danken wir Syrus Mozafar für die hilfreiche Projektbegleitung und Lars Kruse für die fachliche Beratung unseres Projektes.



\section{Themenwahl}

Für das Thema dieser Arbeit wurde eine Variante aus dem Bereich der Algorithmen für kürzeste Pfade zwischen A und B gewählt, nämlich die Ameisenkolonie-Optimierung (ACO). Diese Algorithmen basieren ursprünglich auf dem Verhalten natürlicher Ameisen bei der Futtersuche und sind bei Optimierungsproblemen vielseitig einsetzbar.


???
\begin{itemize}[noitemsep]
\item Überlegungen, Schwierigkeiten
\item Überblick über die Arbeit geben (evtl. auch Programmstruktur?)
\item Wichtige Entscheidungen kurz erwähnen
\item Schwierigkeiten aufzeigen (z.B. bezüglich der Technologie)
\end{itemize}



\subsection{Wahl der Technologie}

Zuerst wurde geprüft, ob das Projekt mit JavaScript und einem Game Framework wie quintus als Website umgesetzt werden könnte (Canvas für 2D). Allerdings hat ein Test gezeigt, dass bereits ab einer Anzahl von 10'000 einzelnen Elementen (sprites) das Rendering in HTML5 bezüglich der Geschwindigkeit überhaupt nicht akzeptabel war. Daher wurde entschieden, den Algorithmus mit Python und dem Framework pygame umzusetzen, das auf der C-Library STL basiert und dessen Leistung sehr gut ist. Das fertige Programm lässt sich so in eine ausführbare Datei umwandeln.



\subsection{Schwierigkeiten}

Weiter unten: Systemspezifische Beschränkungen erwähnen (Leistung), evtl. auf Optimierungsparameter eingehen

???
\begin{itemize}[noitemsep]
\item PGU: Library für Slider und Textfelder, etc.
\item Optimierung: Anzahl Partikel; Speicherbedarf
\item Zwei Modi (mehrere Render-Möglichkeiten des Algorithmus)
\item Anfangs: 2D; trotzdem 3D-Koordinaten einbauen (dafür: WebGL als weiterer Renderer)
\item Einbau von Hindernissen
\end{itemize}




\section{Anforderungen}

Die erstellte Applikation sollte auf einem Computer lauffähig sein (ausführbare Datei), allenfalls in Form einer Webseite in einem Browser laufen. Der Code ist angemessen zu dokumentieren und das Projekt in Form einer Arbeit für ein interessiertes Publikum zu dokumentieren. Am Ende wird das Projekt der ganzen Klasse präsentiert.

Das zu entwickelnde Programm sollte in erster Linie mit guter graphischer Darstellung aufzeigen, wie abstrahierte Ameisen gemäss dem zugrunde gelegten Algorithmus in steigender Anzahl Durchläufen einen zunehmend kürzeren Weg vom Nest zur Futterquelle finden, unter Einfluss des von den Ameisen emittierten Pheromons. Dabei sollte mit der Einstellung verschiedener Parameter die einschlägigen Veränderungen in der Lösungsfindung anschaulich ersichtlich werden. Ideales Ziel wäre eine Konvergenz des Algorithmus. Dagegen standen nicht im Vordergrund, einen möglichst effizienten Algorithmus zu programmieren oder eine ganz spezifische Aufgabe mittels des Programms zu lösen. \\


???
% Vgl. meine Notizen (offiziell und projektspezifisch) \\

Eingrenzung und Abgrenzung der Aufgabenstellung \\

Detailanalyse der Aufgabenstellung (vgl. andere Arbeiten) \\

Formulierung von (Teil-)Zielen \\

\vspace*{1cm}


\section{Theorie zum Algorithmus der Ameisenkolonieoptimierung} 

Die Ameisenkolonie-Optimierung (Ant Colony Optimization, ACO) richtet sich nach dem Verhalten von Ameisen bei der Wegfindung vom Nest zu Futterquellen, um damit verschiedene Probleme der kombinatorischen Optimierung zu lösen (vgl. \cite[S. 1]{sch-koa}). Dabei senden die Ameisen auf Futtersuche den Duftstoff Pheromon aus. Auf kürzeren Wegen ist die Pheromonkonzentration im Laufe der Zeit höher. Andere Ameisen richten sich bei ihrer Wegfindung nach der Höhe des Pheromons, so dass sie eher einen Weg mit hoher Pheromonkonzentration und damit einen kürzeren Pfad einschlagen. Es bildet sich eine sogenannte Ameisenstrasse aus.

Dieses Ameisenverhalten wurde auf Algorithmen übertragen. Der erste dieser Art wurde 1991 von Marco Dorigo publiziert, und zwar zur Lösung des Problems des Handlungsreisenden (Traveling Salesman Problem, TSP). 1999 steuerte Thomas Stützle entscheidende Ergänzungen bei (vgl. \cite{ds-ant, wiki-antalg}). Diese Algorithmen lassen sich grundlegend so charakterisieren: \blockquote{Zwei herausstechende Merkmale sind Einfachheit und Allgemeingültigkeit der Metaheuristik. Die allgemein zugrunde liegenden und abgebildeten Prinzipien erlauben eine vielfältige Ausgestaltung und breit gefächerte Anwendung des Konzepts. Vielfältige ACO-Algorithmen wurden entwickelt. Die ersten Umsetzungen bewiesen die Anwendbarkeit der Metaheuristik zur Lösung NP-harter Optimierungsprobleme, zeigten aber gleichzeitig Probleme auf, wie die vorschnelle Konvergenz in lokale Optima.\footnote{\cite[S. 19]{sch-koa}}}


???Beschreibung der Besonderheiten (Heuristik: nicht zwingend korrekte Lösung) \\

\noindent
ACO-Algorithmen lassen sich insbesondere auf graphenbasierte Probleme anwenden, z.B. für die Routenplanung, für Teilmengenprobleme (Rucksackproblem), im Data Mining, Netzwerk-Routing oder für die Ablaufplanung in Fertigungsprozessen.\footnote{\cite[Vgl.][S. 15ff.]{sch-koa}; \cite[vgl.][]{wiki-antalg}} \\



\vspace*{1cm}
